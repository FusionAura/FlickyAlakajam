using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerScript : MonoBehaviour
{
    private Rigidbody rb;
    [Header("Movement & Jump Variables")]
    public float walkSpeed = 5;
    public float TurnRate = 5;

    [SerializeField] private float moveSpeed = 0;
    [SerializeField] private float acceleration = 7, decceleration = 7;

    [SerializeField] float moveHorizontal = 0, moveVertical = 0, moveHorizontalRaw = 0, moveVerticalRaw = 0, SavedUp = 0, SavedRight = 0;

    Vector3 forward, right, rightMovement, upMovement, heading, surfaceValue = Vector3.zero;

    public float JumpForce = 5;

    private LineRenderer _trail;

    [Header("Slope Variables")]
    //Slope Detection
    [SerializeField] float _slopeForce;
    [SerializeField] float _slopeForceRayLength;
    [SerializeField] bool ground;
    [SerializeField] bool _canJump = true;
    bool wishjump = false;
    public float maxGroundedAngle = 75f;
   
    Vector3 currentGravity; // Just holds some data for us...
    ContactPoint[] cPoints; // ContactPoints are generated by Collision, and they hold lots of fun data.
    Vector3 groundNormal; //The angle that will be perpendicular to the point of contact that our Rigidbody will be grounded on.

    [Header("Other Variables")]
    [SerializeField] public List<GameObject> Followers;
    [SerializeField] public List<GameObject> Goodbye;
    public float calloutRadius = 100;
    public action PlayerState = action.normal;
    public GameControllerScript GamecontrollerObj;

    [Header("Radar Variables")]
    public float SearchTimerMax = 5;
    public float SearchTimer = 5;
    // Start is called before the first frame update
    void Start()
    {
        GamecontrollerObj = GameObject.FindGameObjectWithTag("GameController").GetComponent<GameControllerScript>();
        _trail = GetComponent<LineRenderer>();
        Followers = new List<GameObject>();
        rb = GetComponent<Rigidbody>();

        forward = Camera.main.transform.forward;
        forward.y = 0;
        forward = Vector3.Normalize(forward);
        right = Quaternion.Euler(new Vector3(0,90,0))*forward;
        

    }

    private void OnDrawGizmos()
    {
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireSphere(transform.position, calloutRadius);
    }

    private void FixedUpdate()
    {
        Move();
        Radar();

        if (Followers.Count > 0 && Followers[Followers.Count - 1] != null)
        {
            _trail.SetPosition(Followers.Count  , transform.position);
            _trail.SetPosition(Followers.Count - 1, Followers[Followers.Count-1].transform.position);
        }
        for (int i = 0; i<Followers.Count;i++)
        {
            _trail.SetPosition(i, Followers[i].GetComponent<FollowPlayer>().collisionsSphere.transform.position);
        }
    }

    // Update is called once per frame
    void Update()
    {
        if (ground && rb.velocity.y <=0)
        {
            PlayerState = action.normal;
            _canJump = true;
        }
        ObeyGravity();
        Jump(JumpForce);

    }

    #region Movement
    void Move()
    {
        moveHorizontal = Input.GetAxis("Horizontal");
        moveVertical = Input.GetAxis("Vertical");

        moveHorizontalRaw = Input.GetAxisRaw("Horizontal");
        moveVerticalRaw = Input.GetAxisRaw("Vertical");

        if (moveHorizontalRaw != 0 || moveVerticalRaw != 0)
        {
            rightMovement = right * moveSpeed * Time.fixedDeltaTime * moveHorizontal;
            upMovement = forward * moveSpeed * Time.fixedDeltaTime * moveVertical;

            SavedRight = moveHorizontal;
            SavedUp = moveVertical;

            if (moveSpeed >= walkSpeed)
            {
                moveSpeed = walkSpeed;
            }
            else
            {
                moveSpeed += acceleration * Time.fixedDeltaTime;
            }

            heading = Vector3.Normalize(rightMovement + upMovement);
        }
        else
        {
            rightMovement = right * (moveSpeed * rb.mass) * Time.fixedDeltaTime * SavedRight;
            upMovement = forward * (moveSpeed * rb.mass) * Time.fixedDeltaTime * SavedUp;

            //Decellerate Player speed to 0.
            if (moveSpeed > 0)
            {
                moveSpeed -= decceleration * Time.fixedDeltaTime;
            }
            else
            {
                moveSpeed = 0;
            }
        }
        //Rotate the player in appropriate direction
        if (heading != Vector3.zero)
        {
            //Tuty's solution: https://answers.unity.com/questions/13869/how-do-i-get-smooth-rotation-to-a-point-in-space.html
            Quaternion a = Quaternion.LookRotation(heading, Vector3.up);
            transform.rotation = Quaternion.Slerp(transform.rotation, a, TurnRate * Time.fixedDeltaTime * 2.0f);
        }

        if (PlayerState == action.normal && ground)
        {
            rb.velocity = Vector3.ProjectOnPlane((heading * moveSpeed) + rb.velocity.y * Vector3.up, groundNormal);

            if (rb.velocity.y > 0)
            {
                rb.AddForce(transform.up * -rb.velocity.y, ForceMode.VelocityChange);
            }

            //Need another method to fix this. Applying force downward pushes player down too fast regardless of value.
            //Maybe use cast to detect ground and snap to ground
            else if (rb.velocity.y < 0 && ground == false)
            {
                rb.AddForce(Vector3.up * (rb.velocity.y / 4), ForceMode.VelocityChange);
            }
        }
        else
        {
            rb.velocity = (heading * moveSpeed) + rb.velocity.y * Vector3.up;
        }
    }

    void Jump(float force)
    {
        //Jump
        if (Input.GetButtonDown("Jump"))
        {
            wishjump = true;
        }
        if (wishjump == true && ground && _canJump == true )
        {
            wishjump = false;
            ground = false;
            rb.AddForce(0,force,0, ForceMode.VelocityChange);
            _canJump = false;
            PlayerState = action.jump;
        }
    }

    #endregion

    void Radar()
    {
        if (Input.GetButton("Fire1") && SearchTimer >= SearchTimerMax)
        {
            SearchTimer = 0;
        }
        if (SearchTimer < SearchTimerMax)
        {
            SearchTimer += 1 * Time.fixedDeltaTime;
            Collider[] Callout = Physics.OverlapSphere(transform.position, calloutRadius);
            foreach (Collider a in Callout)
            {
                if (a.gameObject.tag == "Chirp" && a.GetComponent<FollowPlayer>().Following == false)
                {
                    LineRenderer Spirit = a.gameObject.GetComponent<LineRenderer>();
                    Spirit.positionCount = 2;
                    Spirit.SetPosition(0, a.gameObject.transform.position);
                    Spirit.SetPosition(1, transform.position);
                    if (SearchTimer >= SearchTimerMax)
                    {
                        Spirit.positionCount = 1;
                    }
                }
                else if(a.gameObject.tag == "Chirp" && a.GetComponent<FollowPlayer>().Following ==  true)
                {
                    LineRenderer Spirit = a.gameObject.GetComponent<LineRenderer>();
                    Spirit.positionCount = 1;
                }
            }
        }
    }


    #region Credit to user2712865 / Propoc
    //Credit to user2712865 / Propoc
    //https://gamedev.stackexchange.com/questions/146738/how-to-disable-gravity-for-a-rigidbody-moving-on-a-slope
    //
    void ObeyGravity()
    {
        if (ground == false)
        {
            //normal gravity, active when not grounded.
            currentGravity = Physics.gravity;
        }
        else if (ground == true)
        {
            /*Not normal gravity. Instead of going down, we go in the
            direction perpendicular to the angle of where we're standing. 
            This means whatever surface we're grounded on will be 
            effectively the same as standing on a perfectly horizontal 
            surface. Ergo, no sliding will occur. */
            currentGravity = -groundNormal * Physics.gravity.magnitude;
            
        }
        rb.AddForce(currentGravity, ForceMode.Force);
    }

    bool CheckGrounded(Collision newCol)
    {
        cPoints = new ContactPoint[newCol.contactCount];
        newCol.GetContacts(cPoints);


        foreach (ContactPoint cP in cPoints)
        {
            /*If the difference in angle between the direction of gravity
                (usually, downward) and the current surface contacted is
                less than our chosen maximum angle, we've found an
                acceptable place to be grounded.*/
            if (Vector3.Angle(cP.normal, -Physics.gravity.normalized) > maxGroundedAngle  && ground)
            {
                return true;
            }
            if (maxGroundedAngle > Vector3.Angle(cP.normal, -Physics.gravity.normalized) )
            {
                groundNormal = cP.normal;
                               
                return true;
            }
        }
        return false;
    }
    #endregion

    #region Collisions + Triggers
    void OnCollisionStay(Collision ourCollision)
    {
        ground = CheckGrounded(ourCollision);
    }

    //Credit to user2712865 / Propoc
    void OnCollisionExit(Collision ourCollision)
    {
        /*It's okay to not have to check whether or not
         the Collision we're exiting is one we're grounded on,
         because it'll be reaffirmed next time OnCollisionStay runs.*/
        ground = false;
        groundNormal = new Vector3(); //Probably not necessary, but a good habit, in my opinion
    }

    private void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "Chirp")
        {
            FollowPlayer followplayer = other.GetComponent<FollowPlayer>();
            if(followplayer.Saved == false)
            { 
                if (followplayer.Known == false)
                {
                    followplayer.Known = true;
                    GamecontrollerObj.Multiplier += 1;
                    GamecontrollerObj.MultiplierTimer = 0;
                    GamecontrollerObj.IncrementScore(200);
                    GamecontrollerObj.UI.UpdateMultiplier(GamecontrollerObj.Multiplier);
                }
                if (followplayer.CollectDelay >= followplayer.CollectDelayMax)
                {
                    if (!Followers.Contains(other.gameObject)) Followers.Insert(0, other.gameObject);

                    if (Followers.Count == 1)
                    {
                        Followers[0].GetComponent<FollowPlayer>().Leader = gameObject;
                    }
                    else
                    {
                        Followers[0].GetComponent<FollowPlayer>().Leader = Followers[1].gameObject;
                        Followers[1].GetComponent<FollowPlayer>().Follower = Followers[0].gameObject;
                    }

                    //Fuckery that is setting the hitboxes and collisions.
                    followplayer.Following = true;
                    other.gameObject.GetComponent<RotateItem>().enabled = false;

                    followplayer.Hurtbox.enabled = true;
                    followplayer.DetectBox.enabled = false;

                    followplayer.GetComponent<Rigidbody>().velocity = Vector3.zero;
                    followplayer.GetComponent<Rigidbody>().angularVelocity = Vector3.zero;

                    followplayer.collisionsSphere.transform.localPosition = other.gameObject.GetComponent<FollowPlayer>().CollisionsSpherePos;
                    followplayer.Hurtbox.isTrigger = true;

                    other.gameObject.GetComponent<Rigidbody>().isKinematic = false;
                    other.gameObject.GetComponent<Rigidbody>().useGravity = false;

                    _trail.positionCount = Followers.Count + 1;

                    if (Followers.Count == 1)
                    {
                        _trail.SetPosition(0, transform.position);
                        _trail.SetPosition(1, Followers[Followers.Count - 1].GetComponent<FollowPlayer>().collisionsSphere.transform.position);
                    }

                    _trail.SetPosition(Followers.Count, Followers[Followers.Count - 1].GetComponent<FollowPlayer>().collisionsSphere.transform.position);
                }

            }
        }

        if (other.gameObject.tag == "Exit")
        {
            Goodbye.AddRange(Followers);

            Followers.Clear();
            Trail.positionCount = Followers.Count + 1;

            //other.GetComponent<LineRenderer>();
            foreach (GameObject a in Goodbye)
            {
                a.GetComponent<FollowPlayer>().Leader = other.GetComponent<GoalDoor>().SpiritLeader;
                a.GetComponent<FollowPlayer>().WalkSpeed = .05f;
            }
        }

        if (other.gameObject.tag == "Score")
        {
            Destroy(other.gameObject);
            GamecontrollerObj.Multiplier += 1;
            GamecontrollerObj.MultiplierTimer = 0;
            GamecontrollerObj.IncrementScore(10);
            GamecontrollerObj.UI.UpdateMultiplier(GamecontrollerObj.Multiplier); 
        }
    }
    #endregion

    public LineRenderer Trail
    {
        set { _trail = value; }
        get { return _trail; }
    }

    public enum action { normal, jump}
}
